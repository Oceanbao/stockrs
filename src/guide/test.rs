#![allow(dead_code)]

use std::sync::atomic::AtomicI32;
use std::sync::Arc;

// Code generated by lazy_static
#[allow(missing_copy_implementations)]
#[allow(non_camel_case_types)]
#[allow(dead_code)]
struct COUNT_T {
    __private_field: (),
}
#[doc(hidden)]
static COUNT_T: COUNT_T = COUNT_T {
    __private_field: (),
};
// Lib impl Deref (alised to __Deref)
impl ::lazy_static::__Deref for COUNT_T {
    type Target = Arc<AtomicI32>;
    fn deref(&self) -> &Arc<AtomicI32> {
        #[inline(always)]
        fn __static_ref_initialize() -> Arc<AtomicI32> {
            // This block will be replaced with the init code
            // supplied by us - a single line
            Arc::new(AtomicI32::new(0))
        }
        #[inline(always)]
        fn __stability() -> &'static Arc<AtomicI32> {
            // Uses std::sync::Once internall
            static LAZY: ::lazy_static::lazy::Lazy<Arc<AtomicI32>> =
                ::lazy_static::lazy::Lazy::INIT;
            LAZY.get(__static_ref_initialize)
        }
        __stability()
    }
}
impl ::lazy_static::LazyStatic for COUNT_T {
    fn initialize(lazy: &Self) {
        let _ = &**lazy;
    }
}

#[cfg(test)]
mod tests {
    use lazy_static::lazy_static;
    use std::sync::atomic::{AtomicI32, Ordering};
    use std::sync::Mutex;

    // `lazy_static` handles details of init data at RT:
    // when it's first read, auto-init and globally.
    lazy_static! {
        static ref COUNT: AtomicI32 = AtomicI32::new(0);
        static ref MUTEX: Mutex<i32> = Mutex::new(0);
    }

    // lazy_static helps solving sharing global state, but not sync
    // use 1 thread explicitly in test (default parallel) or use mutex
    #[test]
    fn test_count() {
        COUNT.fetch_add(1, Ordering::SeqCst);
    }

    #[test]
    fn first_test() {
        let _guard = MUTEX.lock().expect("fail to acquire lock");
        println!("first test running");
    }

    #[test]
    fn second_test() {
        let _guard = MUTEX.lock().expect("fail to acqurie lock");
        println!("second test running");
    }
}
